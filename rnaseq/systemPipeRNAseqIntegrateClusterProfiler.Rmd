---
title: RNA-Seq Workflow Template 
author: "First/last name (first.last@ucr.edu)"
date: "Last update: `r format(Sys.time(), '%d %B, %Y')`" 
output:
  html_document:
    toc: true
    toc_float:
        collapsed: true
        smooth_scroll: true
    toc_depth: 3
    fig_caption: yes
    code_folding: show
    number_sections: true

fontsize: 14pt
bibliography: bibtex.bib
---

<!--
- Compile from command-line
time Rscript -e "rmarkdown::render('systemPipeRNAseq.Rmd', c('html_document'), clean=F); knitr::knit('systemPipeRNAseq.Rmd', tangle=TRUE)"; Rscript ../md2jekyll.R systemPipeRNAseq.knit.md 12; Rscript -e "rmarkdown::render('systemPipeRNAseq.Rmd', c('pdf_document'))"
-->

```{r style, echo = FALSE, results = 'asis'}
system("echo HOSTNAME HOSTNAME HOSTNAME HOSTNAME HOSTNAME HOSTNAME HOSTNAME")
system("hostname") # should return name of a compute node starting with i or c 
BiocStyle::markdown()
options(width=100, max.print=1000)
knitr::opts_chunk$set(
    eval=as.logical(Sys.getenv("KNITR_EVAL", "TRUE")),
    cache=F) # as.logical(Sys.getenv("KNITR_CACHE", "TRUE")))
doallchunks = TRUE # took 21m46 on pigeon on 2017-0725, now 14m on intel partition
#doallchunks = FALSE
doallCPchunks = TRUE
#doallCPchunks = FALSE
doallClusterRunchunks = TRUE
#doallClusterRunchunks = FALSE
# cat <- function(...) {} # use this to disable all cat() calls below (for windows)
```

```{r node_environment, eval=FALSE}
# push `F2` on your keyboard to open interactive R session
q("no") # closes R session on head node
srun --x11 --partition=intel --mem=2gb --cpus-per-task 1 --ntasks 1 --time 07-0:00:00 --pty bash -l

R
```

Now check whether your R session is running on a computer node of the cluster and not on a head node.

```{r r_environment, eval=doallchunks}
system("echo HOSTNAME HOSTNAME HOSTNAME HOSTNAME HOSTNAME HOSTNAME HOSTNAME")
system("hostname") # should return name of a compute node starting with i or c 
getwd() # checks current working directory of R session
dir() # returns content of current working directory
```
```{r r_environment2, eval=F}
sort( sapply(ls(),function(x){object.size(get(x))}))
sort( sapply(mget(ls()),object.size) )
sort(sapply(ls(), function(x) format(object.size(get(x)), unit = 'auto')))
library(RenvCheck) # Jordan's environment checker for systemPipeR
detach(package:RenvCheck)
search()
rm(counteByg); rm(align); rm(fqlist); rm(desc); rm(speciesMap)
save.image()
```
```{r setup, echo=FALSE, messages=FALSE, warnings=FALSE}
suppressPackageStartupMessages({
    library(systemPipeR)
    library(BiocParallel)
    library(Biostrings)
    library(Rsamtools)
    library(GenomicRanges)
    library(ggplot2)
    library(GenomicAlignments)
    library(ShortRead)
    library(ape)
    library(clusterProfiler)
})
```
Note: the most recent version of this tutorial can be found <a href="https://htmlpreview.github.io/?https://github.com/tgirke/systemPipeR/blob/master/vignettes/systemPipeRNAseq.html">here</a> and a short overview slide show [here](https://htmlpreview.github.io/?https://github.com/tgirke/systemPipeR/master/inst/extdata/slides/systemPipeRslides.html).

# Introduction

Users want to provide here background information about the design of their RNA-Seq project.


# Samples and environment settings

## Environment settings and input data

Typically, the user wants to record here the sources and versions of the
reference genome sequence along with the corresponding annotations. In
the provided sample data set all data inputs are stored in a `data`
subdirectory and all results will be written to a separate `results` directory,
while the `systemPipeRNAseq.Rmd` script and the `targets` file are expected to be located in the parent
directory. The R session is expected to run from this parent directory.

To run this sample report, mini sample FASTQ and reference genome files
can be downloaded from
[here](http://biocluster.ucr.edu/~tgirke/projects/systemPipeR_test_data.zip).
The chosen data set [SRP010938](http://www.ncbi.nlm.nih.gov/sra/?term=SRP010938)
contains 18 paired-end (PE) read sets from *Arabidposis thaliana*
[@Howard2013-fq]. To minimize processing time during testing, each FASTQ
file has been subsetted to 90,000-100,000 randomly sampled PE reads that
map to the first 100,000 nucleotides of each chromosome of the *A.
thalina* genome. The corresponding reference genome sequence (FASTA) and
its GFF annotion files (provided in the same download) have been
truncated accordingly. This way the entire test sample data set is less
than 200MB in storage space. A PE read set has been chosen for this test
data set for flexibility, because it can be used for testing both types
of analysis routines requiring either SE (single end) reads or PE reads.

The following loads one of the available NGS workflow templates (here RNA-Seq)
into the user's current working directory. At the moment, the package includes
workflow templates for RNA-Seq, ChIP-Seq, VAR-Seq and Ribo-Seq. Templates for
additional NGS applications will be provided in the future.

```{r genRna_workflow, eval=FALSE}
library(systemPipeRdata)
genWorkenvir(workflow="rnaseq")
setwd("rnaseq")
```

Alternatively, this can be done from the command-line as follows:

```{sh genRna_workflow_command_line, eval=FALSE}
Rscript -e "systemPipeRdata::genWorkenvir(workflow='rnaseq')"
```

Now open the R markdown script `systemPipeRNAseq.Rmd`in your R IDE (_e.g._
vim-r or RStudio) and run the workflow as outlined below. If you work under
Vim-R-Tmux, the following command sequence will connect the user in an
interactive session with a node on the cluster. The code of the `Rmd`
script can then be sent from Vim on the login (head) node to an open R session running
on the corresponding computer node. This is important since Tmux sessions
should not be run on the computer nodes. 

NOTE: chunks node_environment and r_environment were here,
	now moved to top of file for convenience.

## Required packages and resources

The `systemPipeR` package needs to be loaded to perform the analysis steps shown in
this report [@H_Backman2016-bt].  ```{r load_systempiper, eval=TRUE}
library(systemPipeR)
```

If applicable load custom functions not provided by

```{r source_helper_fcts, eval=FALSE}
source("systemPipeRNAseq_Fct.R")
```
## Experiment definition provided by `targets` file

The `targets` file defines all FASTQ files and sample
comparisons of the analysis workflow.

```{r load_targets, collapse=T, eval=TRUE}
targetspath <- system.file("extdata", "targets.txt", package="systemPipeR")
targetspath
# system('cat ') # dangerous, puts cat on stdin - hangs batch jobs
# system(paste0('cat ', targetspath))
cat(system('cat "/bigdata/bioinfo/pkgadmin/opt/linux/centos/7.x/x86_64/pkgs/R/3.4.0/lib64/R/library/systemPipeR/extdata/targets.txt"', intern = T), sep = '\n')
targets <- read.delim(targetspath, comment.char = "#")[,1:4] # all rows, 4 columns
str(targets)
targets
# now look inside the fastq.gz file at the seq ID, sequence and quality data
cat(system(paste0('gzip -cd ', targets[1,1], '.gz | head'), intern = T), sep = '\n')
cat(system('ls -l data', intern = T), sep = '\n') # system output doesn't knit to html
cat(system('ls -l', intern = T), sep = '\n') # system output doesn't knit to html
# dir()
```

# (3)Read preprocessing

## Read quality filtering and trimming

The function `preprocessReads` allows to apply predefined or custom
read preprocessing functions to all FASTQ files referenced in a
`SYSargs` container, such as quality filtering or adaptor trimming
routines.  The following example performs adaptor trimming with
the `trimLRPatterns` function from the `Biostrings` package.
After the trimming step a new targets file is generated (here
`targets_trim.txt`) containing the paths to the trimmed FASTQ files.
The new targets file can be used for the next workflow step with an updated
`SYSargs` instance, _e.g._ running the NGS alignments using the
trimmed FASTQ files.

```{r fastq_filter, eval=doallchunks}

cat(system(paste0('cat param/trim.param'), intern = T), sep = '\n')
args <- systemArgs(sysma="param/trim.param", mytargets="targets.txt")
args
names(args); modules(args); cores(args); outpaths(args); sysargs(args)
showClass("SYSargs")
systemPipeR::preprocessReads(args=args, Fct="Biostrings::trimLRPatterns(Rpattern='GCCCGGGTAA', subject=fq)",
                batchsize=100000, overwrite=TRUE, compress=TRUE)
systemPipeR::writeTargetsout(x=args, file="targets_trim.txt", overwrite=TRUE)
outpaths(args)[1]
cat(system(paste0('cat targets_trim.txt'), intern = T), sep = '\n')
cat(system(paste0('zcat results/SRR446027_1.fastq_trim.gz | head'), intern = T), sep = '\n')
```

## FASTQ quality report

The following `seeFastq` and `seeFastqPlot` functions generate and plot a series of useful 
quality statistics for a set of FASTQ files including per cycle quality box
lots, base proportions, base-level quality trends, relative k-mer
diversity, length and occurrence distribution of reads, number of reads
above quality cutoffs and mean quality distribution. The results are
written to a PDF file named `fastqReport.pdf`.

```{r fastq_report, eval=doallchunks}
cat(system(paste0('cat param/tophat.param'), intern = T), sep = '\n')
cat(system(paste0('cat targets.txt'), intern = T), sep = '\n')
args <- systemArgs(sysma="param/tophat.param", mytargets="targets.txt")
args
names(args); modules(args); cores(args); outpaths(args); sysargs(args)
names(args)
modules(args)
cores(args)
outpaths(args)
sysargs(args) # shows tophat calls
sysargs(args)[1] # Command-line parameters for first FASTQ file
cat('Next line takes time 6 minutes.\n') # takes 6 minutes
fqlist <- systemPipeR::seeFastq(fastq=infile1(args), batchsize=100000, klength=8)
save(fqlist, file="data/GO/fqlist.RData")
load("data/GO/fqlist.RData")
cat('fqlist is a Large list (18 * 9 elements, 1.3 Mb)\n')
str(fqlist, max.level = 1)
str(fqlist[[1]])
if (FALSE) {
fqlist[[1]][1] # lots of data here, best to visualize with seeFastqPlot?
fqlist[['M1A']]['fqstats']
fqlist[['M1A']]['astats']
fqlist[['M1A']]['bstats']
fqlist[['M1A']]['cstats']
fqlist[['M1A']]['dstats']
fqlist[['M1A']]['estats']
fqlist[['M1A']]['fstats']
fqlist[['M1A']]['gstats']
fqlist[['M1A']]['hstats']
summary(fqlist)
summary(fqlist[['M1A']])
summary(fqlist[['M1A']][[1]])
summary(fqlist[['M1A']][[2]])
summary(fqlist[['M1A']][[3]])
summary(fqlist[['M1A']][[4]])
summary(fqlist[['M1A']][[5]])
summary(fqlist[['M1A']][[6]])
summary(fqlist[['M1A']][[7]])
summary(fqlist[['M1A']][[8]])
summary(fqlist[['M1A']][[9]])
}
pdf("./results/fastqReport.pdf", height=18, width=4*length(fqlist))
systemPipeR::seeFastqPlot(fqlist)
dev.off()
# Neerja help me read/understand the pdf contents
``` 

![](results/fastqReport.png)
<div align="center">Figure 1: FASTQ quality report for 18 samples</div></br>


# (4)Alignments

## Read mapping with `Bowtie2/Tophat2` 

The NGS reads of this project will be aligned against the reference
genome sequence using `Bowtie2/TopHat2` [@Kim2013-vg; @Langmead2012-bs]. The parameter 
settings of the aligner are defined in the `tophat.param` file.

```{r tophat_alignment1, eval=T}
args <- systemArgs(sysma="param/tophat.param", mytargets="targets.txt")
sysargs(args)[1] # Command-line parameters for first FASTQ file
```


Submission of alignment jobs to compute cluster, here using 72 CPU cores
(18 `qsub` processes each with 4 CPU cores).

```{r tophat_alignment2, eval=doallClusterRunchunks}
# ?moduleload
# q
args
modules(args)
systemPipeR::moduleload(modules(args))
# next line says Building a SMALL index
system('pwd')
cat(system("bowtie2-build ./data/tair10.fasta ./data/tair10.fasta > results/bowtie2-build.out 2> results/bowtie2-build.err", intern = T), sep = '\n')
system('pwd')
cat(system(paste0('cat results/bowtie2-build.err'), intern = T), sep = '\n')
cat(system(paste0('cat results/bowtie2-build.out'), intern = T), sep = '\n')

resources <- list(walltime="01:00:00", ntasks=1, ncpus=cores(args), memory="10G")
resources
args
names(args)
modules(args)
cores(args)
outpaths(args)
sysargs(args) # shows tophat calls
cat(system(paste0('cat .BatchJobs.R'), intern = T), sep = '\n')
cat(system(paste0('cat slurm.tmpl'), intern = T), sep = '\n')
reg <- systemPipeR::clusterRun(args, conffile=".BatchJobs.R", template="slurm.tmpl", Njobs=18, runid="01",
                  resourceList=resources)
# creates results/star.tophat # do I want to look at these also?
# don't submit for 20 hours on short-list!
# 1 minute
reg
waitForJobs(reg)
```

## Read mapping with `HISAT2`

```{r hisat_alignment2, eval=doallClusterRunchunks}
args <- systemArgs(sysma="param/hisat2.param", mytargets="targets.txt")
cat(system(paste0('cat param/hisat2.param'), intern = T), sep = '\n')
names(args)
modules(args)
cores(args)
outpaths(args)
sysargs(args) # shows hisat2 calls
sysargs(args)[1] # Command-line parameters for first FASTQ file
moduleload(modules(args))
system('pwd')
cat(system("hisat2-build ./data/tair10.fasta ./data/tair10.fasta > results/hisat2-build.out 2> results/hisat2-build.err", intern = T), sep = '\n')
system('pwd')
cat(system(paste0('cat results/hisat2-build.err'), intern = T), sep = '\n')
cat(system(paste0('cat results/hisat2-build.out'), intern = T), sep = '\n')
resources <- list(walltime="01:00:00", ntasks=1, ncpus=cores(args), memory="10G")
resources
reg <- clusterRun(args, conffile=".BatchJobs.R", template="slurm.tmpl", Njobs=18, runid="01",
                  resourceList=resources)
# don't submit for 20 hours on short-list!
# 1 minute
reg
waitForJobs(reg)
```

Check whether all BAM files have been created

```{r check_files_exist, eval=T}
outpaths(args)
file.exists(outpaths(args))
```

## Read and alignment stats

The following provides an overview of the number of reads in each sample
and how many of them aligned to the reference.

```{r align_stats, eval=doallchunks}
read_statsDF <- systemPipeR::alignStats(args=args) 
read_statsDF
write.table(read_statsDF, "results/alignStats.xls", row.names=FALSE, quote=FALSE, sep="\t")
```

The following shows the alignment statistics for a sample file provided by the `systemPipeR` package. 

```{r align_stats_view, eval=TRUE}
read.table(system.file("extdata", "alignStats.xls", package="systemPipeR"), header=TRUE)[1:4,]
```


## Create symbolic links for viewing BAM files in IGV

The `symLink2bam` function creates symbolic links to view the BAM alignment files in a
genome browser such as IGV. The corresponding URLs are written to a file
with a path specified under `urlfile` in the `results` directory.

```{r bam_urls, eval=F}
symLink2bam(sysargs=args, htmldir=c("~/.html/", "somedir/"), 
            urlbase="http://biocluster.ucr.edu/~tgirke/", 
	        urlfile="./results/IGVurl.txt")
```


# (5)Read quantification

## Read counting with `summarizeOverlaps` in parallel mode using multiple cores

Reads overlapping with annotation ranges of interest are counted for
each sample using the `summarizeOverlaps` function [@Lawrence2013-kt]. The read counting is
preformed for exonic gene regions in a non-strand-specific manner while
ignoring overlaps among different genes. Subsequently, the expression
count values are normalized by *reads per kp per million mapped reads*
(RPKM). The raw read count table (`countDFeByg.xls`) and the correspoding 
RPKM table (`rpkmDFeByg.xls`) are written
to separate files in the directory of this project. Parallelization is
achieved with the `BiocParallel` package, here using 8 CPU cores.

```{r read_counting1, eval=T}
# uses >3GB memory
library("GenomicFeatures"); library(BiocParallel)
cat(system(paste0('head data/tair10.gff'), intern = T), sep = '\n')
cat(system(paste0('tail data/tair10.gff'), intern = T), sep = '\n')
txdb <- GenomicFeatures::makeTxDbFromGFF(file="data/tair10.gff", format="gff", dataSource="TAIR", organism="Arabidopsis thaliana")
txdb
saveDb(txdb, file="./data/tair10.sqlite")
txdb <- loadDb("./data/tair10.sqlite")
outpaths(args)[1]
(align <- GenomicAlignments::readGAlignments(outpaths(args)[1])) # Demonstrates how to read bam file into R
align

eByg <- GenomicFeatures::exonsBy(txdb, by=c("gene"))
eByg
bfl <- Rsamtools::BamFileList(outpaths(args), yieldSize=50000, index=character())
bfl
multicoreParam <- MulticoreParam(workers=2); register(multicoreParam); registered()
multicoreParam
counteByg <- bplapply(bfl, function(x) GenomicAlignments::summarizeOverlaps(eByg, x, mode="Union", 
                                               ignore.strand=TRUE, 
                                               inter.feature=FALSE, 
                                               singleEnd=TRUE)) 
str(counteByg)
counteByg
countDFeByg <- sapply(seq(along=counteByg), function(x) SummarizedExperiment::assays(counteByg[[x]])$counts)
str(countDFeByg)
countDFeByg
rownames(countDFeByg) <- names(rowRanges(counteByg[[1]])); colnames(countDFeByg) <- names(bfl)
rownames(countDFeByg)
rpkmDFeByg <- apply(countDFeByg, 2, function(x) returnRPKM(counts=x, ranges=eByg))
str(rpkmDFeByg)
rpkmDFeByg
write.table(countDFeByg, "results/countDFeByg.xls", col.names=NA, quote=FALSE, sep="\t")
write.table(rpkmDFeByg, "results/rpkmDFeByg.xls", col.names=NA, quote=FALSE, sep="\t")
```

Sample of data slice of count table
```{r view_counts, eval=T} # always T
read.delim("results/countDFeByg.xls", row.names=1, check.names=FALSE)[1:4,1:5]
```

Sample of data slice of RPKM table

```{r view_rpkm, eval=T} # always T
read.delim("results/rpkmDFeByg.xls", row.names=1, check.names=FALSE)[1:4,1:4]
```

Note, for most statistical differential expression or abundance analysis
methods, such as `edgeR` or `DESeq2`, the raw count values should be used as input. The
usage of RPKM values should be restricted to specialty applications
required by some users, *e.g.* manually comparing the expression levels
among different genes or features.

## Sample-wise correlation analysis

The following computes the sample-wise Spearman correlation coefficients from
the `rlog` transformed expression values generated with the `DESeq2` package. After
transformation to a distance matrix, hierarchical clustering is performed with
the `hclust` function and the result is plotted as a dendrogram
(also see file `sample_tree.pdf`).

```{r sample_tree, eval=T}
library(DESeq2, quietly=TRUE); library(ape,  warn.conflicts=FALSE)
countDF <- as.matrix(read.table("./results/countDFeByg.xls"))
str(countDF)
countDF # exactly the same as countDFeByg above
countDF[1:6,1:18]
head(countDF)
showClass("SYSargs")
systemPipeR::targetsin(args)$SampleName
targetsin(args)$Factor
colData <- data.frame(row.names=targetsin(args)$SampleName, condition=targetsin(args)$Factor)
colData
dds <- DESeq2::DESeqDataSetFromMatrix(countData = countDF, colData = colData, design = ~ condition)
dds
d <- stats::cor(SummarizedExperiment::assay(DESeq2::rlog(dds)), method="spearman")
d
hc <- stats::hclust(dist(1-d))
hc
grDevices::pdf("results/sample_tree.pdf")
ape::plot.phylo(ape::as.phylo(hc), type="p", edge.col="blue", edge.width=2, show.node.label=TRUE, no.margin=TRUE)
grDevices::dev.off()
```

![](results/sample_tree.png)
<div align="center">Figure 2: Correlation dendrogram of samples</div></br>

# (6)Analysis of DEGs

The analysis of differentially expressed genes (DEGs) is performed with
the glm method of the `edgeR` package [@Robinson2010-uk]. The sample
comparisons used by this analysis are defined in the header lines of the 
`targets.txt` file starting with `<CMP>`.


## Run `edgeR`

```{r run_edger, eval=T}
library(edgeR)
countDF <- read.delim("results/countDFeByg.xls", row.names=1, check.names=FALSE)
head(countDF) # best way to see counts!
targets <- utils::read.delim("targets.txt", comment="#")
targets
cmp <- systemPipeR::readComp(file="targets.txt", format="matrix", delim="-")
cmp
edgeDF <- systemPipeR::run_edgeR(countDF=countDF, targets=targets, cmp=cmp[[1]], independent=FALSE, mdsplot="")
str(edgeDF)
edgeDF
```

Add gene descriptions

```{r custom_annot, eval=T}
# useMart() call fails if mart is down for maintenance
library("biomaRt")
m <- biomaRt::useMart("plants_mart", dataset="athaliana_eg_gene", host="plants.ensembl.org")
m
desc <- biomaRt::getBM(attributes=c("tair_locus", "description"), mart=m)
# desc # too big to print
str(desc)
head(desc)
# m <- useMart("ensembl", dataset="xmaculatus_gene_ensembl", host="ensembl.org")
# desc <- getBM(attributes=c("band", "description"), mart=m)
desc <- desc[!base::duplicated(desc[,1]),]
descv <- as.character(desc[,2]); names(descv) <- as.character(desc[,1])
save(descv, file="descv.RData") # save for clusterProfiler work
str(descv)
head(descv)
names(descv) # this is the list for clusterProfiler
edgeDF <- data.frame(edgeDF, Desc=descv[rownames(edgeDF)], check.names=FALSE)
str(edgeDF)
summary(edgeDF)
head(edgeDF)
write.table(edgeDF, "./results/edgeRglm_allcomp.xls", quote=FALSE, sep="\t", col.names = NA)
```

## Plot DEG results

Filter and plot DEG results for up and down regulated genes. The
definition of *up* and *down* is given in the corresponding help
file. To open it, type `?filterDEGs` in the R console.

```{r filter_degs, eval=T}
edgeDF <- read.delim("results/edgeRglm_allcomp.xls", row.names=1, check.names=FALSE) 
str(edgeDF)
summary(edgeDF)
head(edgeDF)
pdf("results/DEGcounts.pdf")
DEG_list <- systemPipeR::filterDEGs(degDF=edgeDF, filter=c(Fold=2, FDR=20))
# finally a DEG list
str(DEG_list)
DEG_list
DEG_list$Summary
dev.off()
write.table(DEG_list$Summary, "./results/DEGcounts.xls", quote=FALSE, sep="\t", row.names=FALSE)
```

![](results/DEGcounts.png)
<div align="center">Figure 3: Up and down regulated DEGs with FDR of 1%</div></br>

## Venn diagrams of DEG sets

The `overLapper` function can compute Venn intersects for large numbers of sample
sets (up to 20 or more) and plots 2-5 way Venn diagrams. A useful
feature is the possiblity to combine the counts from several Venn
comparisons with the same number of sample sets in a single Venn diagram
(here for 4 up and down DEG sets).


```{r venn_diagram, eval=T}
vennsetup <- overLapper(DEG_list$Up[6:9], type="vennsets")
vennsetup
vennsetdown <- overLapper(DEG_list$Down[6:9], type="vennsets")
vennsetdown
pdf("results/vennplot.pdf")
vennPlot(list(vennsetup, vennsetdown), mymain="", mysub="", colmode=2, ccol=c("blue", "red"))
dev.off()
```

![](results/vennplot.png)
<div align="center">Figure 4: Venn Diagram for 4 Up and Down DEG Sets</div></br>

# (7)GO term enrichment analysis

## Obtain gene-to-GO mappings

The following shows how to obtain gene-to-GO mappings from `biomaRt` (here for *A.
thaliana*) and how to organize them for the downstream GO term
enrichment analysis. Alternatively, the gene-to-GO mappings can be
obtained for many organisms from Bioconductors  `.db` genome annotation
packages or GO annotation files provided by various genome databases.
For each annotation this relatively slow preprocessing step needs to be
performed only once. Subsequently, the preprocessed data can be loaded
with the `load` function as shown in the next subsection.

```{r get_go_annot, eval=doallchunks}
# useMart() fails if mart is down for maintenance
library("biomaRt")

listMarts(host="plants.ensembl.org")
m <- useMart("plants_mart", host="plants.ensembl.org")
listDatasets(m)
listDatasets(m)[44,]
m <- useMart("plants_mart", dataset="athaliana_eg_gene", host="plants.ensembl.org")
listAttributes(m) # Choose data types you want to download
go <- getBM(attributes=c("go_id", "tair_locus", "name_1006"), mart=m)
str(go)
go <- go[go[,3]!="",]; go[,3] <- as.character(go[,3])
str(go)
go[go[,3]=="molecular_function", 3] <- "F"; go[go[,3]=="biological_process", 3] <- "P"; go[go[,3]=="cellular_component", 3] <- "C"
str(go)
go[1:4,]

if (FALSE) { 

listMarts() # To choose BioMart database
listMarts(host="plants.ensembl.org")
m <- useMart("ensembl", host="ensembl.org")
listDatasets(m) # Choose data types you want to download
m <- useMart("ensembl", dataset="xmaculatus_gene_ensembl", host="ensembl.org")
listAttributes(m)
go <- getBM(attributes=c("go_id", "band", "name_1006"), mart=m)
go <- go[go[,3]!="",]; go[,3] <- as.character(go[,3])
go[go[,3]=="molecular_function", 3] <- "F"; go[go[,3]=="biological_process", 3] <- "P"; go[go[,3]=="cellular_component", 3] <- "C"
go[1:4,]

}
dir.create("./data/GO")
write.table(go, "data/GO/GOannotationsBiomart_mod.txt", quote=FALSE, row.names=FALSE, col.names=FALSE, sep="\t")
catdb <- systemPipeR::makeCATdb(myfile="data/GO/GOannotationsBiomart_mod.txt", lib=NULL, org="", colno=c(1,2,3), idconv=NULL)
# makeCATdb() is part of systemPipeR::GOHyperGALL
catdb
save(catdb, file="data/GO/catdb.RData")
```

## Batch GO term enrichment analysis

Apply the enrichment analysis to the DEG sets obtained the above differential
expression analysis. Note, in the following example the `FDR` filter is set
here to an unreasonably high value, simply because of the small size of the toy
data set used in this vignette. Batch enrichment analysis of many gene sets is
performed with the function. When `method=all`, it returns all GO terms passing
the p-value cutoff specified under the `cutoff` arguments. When `method=slim`,
it returns only the GO terms specified under the `myslimv` argument. The given
example shows how a GO slim vector for a specific organism can be obtained from
BioMart.


```{r go_enrich, eval=doallchunks}
# takes time :45
library("biomaRt")
load("data/GO/catdb.RData")
DEG_list <- filterDEGs(degDF=edgeDF, filter=c(Fold=2, FDR=50), plot=FALSE)
str(DEG_list) # Actual DEG_list
DEG_list
up_down <- DEG_list$UporDown; names(up_down) <- paste(names(up_down), "_up_down", sep="")
str(up_down) # list of up_down's for 9 CMP's
up_down
up <- DEG_list$Up; names(up) <- paste(names(up), "_up", sep="")
up
down <- DEG_list$Down; names(down) <- paste(names(down), "_down", sep="")
down
DEGlist <- c(up_down, up, down)
str(DEGlist) # now list of 27
DEGlist
DEGlist <- DEGlist[sapply(DEGlist, length) > 0]
str(DEGlist) # now list of 19 (blanks are gone)
DEGlist
save(DEGlist, file="DEGlist.RData") # save for clusterProfiler work
BatchResult <- systemPipeR::GOCluster_Report(catdb=catdb, setlist=DEGlist, method="all", id_type="gene", CLSZ=2, cutoff=0.9, gocats=c("MF", "BP", "CC"), recordSpecGO=NULL)
# GOCluster_Report is part of GOHyperGALL which is similar to GOstats::GOHyperG
# GOCluster_Report is batch analysis of many gene sets
str(BatchResult)
BatchResult
library("biomaRt")
m <- useMart("plants_mart", dataset="athaliana_eg_gene", host="plants.ensembl.org")
# m <- useMart("ensembl", dataset="xmaculatus_gene_ensembl", host="ensembl.org")
goslimvec <- as.character(getBM(attributes=c("goslim_goa_accession"), mart=m)[,1])
goslimvec
BatchResultslim <- GOCluster_Report(catdb=catdb, setlist=DEGlist, method="slim", id_type="gene", myslimv=goslimvec, CLSZ=10, cutoff=0.01, gocats=c("MF", "BP", "CC"), recordSpecGO=NULL)
str(BatchResultslim)
BatchResultslim
save(BatchResultslim, file="data/GO/BatchResultslim.RData")
```

## Plot batch GO term results

The `data.frame` generated by `GOCluster` can be plotted with the `goBarplot` function. Because of the
variable size of the sample sets, it may not always be desirable to show
the results from different DEG sets in the same bar plot. Plotting
single sample sets is achieved by subsetting the input data frame as
shown in the first line of the following example.

```{r go_plot, eval=doallchunks}
load("data/GO/BatchResultslim.RData")
gos <- BatchResultslim[grep("M6-V6_up_down", BatchResultslim$CLID), ]
str(gos)
gos
gos <- BatchResultslim
str(gos)
gos
pdf("GOslimbarplotMF.pdf", height=8, width=10); goBarplot(gos, gocat="MF"); dev.off()
goBarplot(gos, gocat="BP")
goBarplot(gos, gocat="CC")
```

![](results/GOslimbarplotMF.png)
<div align="center">Figure 5: GO Slim Barplot for MF Ontology</div></br>

# (8)Clustering and heat maps

The following example performs hierarchical clustering on the `rlog`
transformed expression matrix subsetted by the DEGs identified in the above
differential expression analysis. It uses a Pearson correlation-based distance
measure and complete linkage for cluster joining.

```{r heatmap, eval=T}
library(pheatmap)
geneids <- unique(as.character(unlist(DEG_list[[1]])))
geneids
y <- assay(rlog(dds))[geneids, ]
y
pdf("heatmap1.pdf")
pheatmap(y, scale="row", clustering_distance_rows="correlation", clustering_distance_cols="correlation")
dev.off()
```

![](results/heatmap1.png)
<div align="center">Figure 6: Heat Map with Hierarchical Clustering Dendrograms of DEGs</div></br>

# (9)clusterProfiler Integration

```{r try.clusterProfiler.html.bitr, eval=doallCPchunks}
library(org.Hs.eg.db) # Homo sapiens
keytypes(org.Hs.eg.db)
x <- c("GPX3",  "GLRX",   "LBP",   "CRYAB", "DEFB1", "HCLS1",   "SOD2",   "HSPA2",
       "ORM1",  "IGFBP1", "PTHLH", "GPC3",  "IGFBP3","TOB1",    "MITF",   "NDRG1",
       "NR1H4", "FGFR3",  "PVR",   "IL6",   "PTPRM", "ERBB2",   "NID2",   "LAMB1",
       "COMP",  "PLS3",   "MCAM",  "SPP1",  "LAMC1", "COL4A2",  "COL4A1", "MYOC",
       "ANXA4", "TFPI2",  "CST6",  "SLPI",  "TIMP2", "CPM",     "GGT1",   "NNMT",
       "MAL",   "EEF1A2", "HGD",   "TCN2",  "CDA",   "PCCA",    "CRYM",   "PDXK",
       "STC1",  "WARS",  "HMOX1", "FXYD2", "RBP4",   "SLC6A12", "KDELR3", "ITM2B")
eg = bitr(x, fromType="SYMBOL", toType="ENTREZID", OrgDb="org.Hs.eg.db")
head(eg)
eg

library(org.At.tair.db) # Arabidopsis thaliana
keytypes(org.At.tair.db)
load(file="descv.RData")
length(names(descv)) # descv is from line 521 
de = names(descv)[1:100]
de = names(descv)
str(de)
length(de)
head(de)
eg = bitr(de, fromType="TAIR", toType=c("ENTREZID","SYMBOL","GO"), OrgDb="org.At.tair.db", drop = FALSE)
eg = bitr(de, fromType="TAIR", toType=c("GOALL"), OrgDb="org.At.tair.db", drop = FALSE)
str(eg)
head(eg)
nrow(eg)
eg
```

```{r try.clusterProfiler.pdf.pg5.compareCluster, eval=doallCPchunks}
# takes time 5:00
# still need to work on two formula interfaces

## Not run:
data(gcSample)
str(gcSample)
# head(gcSample)

xx <- compareCluster(gcSample, fun="enrichKEGG", organism="hsa", pvalueCutoff=0.05)
str(xx)
as.data.frame(xx)
# graphics::plot(xx, type="dot", caption="KEGG Enrichment Comparison")

## formula interface
mydf <- data.frame(Entrez=c('1', '100', '1000', '100101467', '100127206', '100128071'),
group = c('A', 'A', 'A', 'B', 'B', 'B'),
othergroup = c('good', 'good', 'bad', 'bad', 'good', 'bad'))

xx.formula <- compareCluster(Entrez~group, data=mydf,
fun='groupGO', OrgDb='org.Hs.eg.db')
str(xx.formula)
as.data.frame(xx.formula) # takes a minute or so

## formula interface with more than one grouping variable
xx.formula.twogroups <- compareCluster(Entrez~group+othergroup, data=mydf,
fun='groupGO', OrgDb='org.Hs.eg.db')
str(xx.formula.twogroups)
as.data.frame(xx.formula.twogroups) # takes a minute or so
## End(Not run)

# my code
# get edgeDF from line 518 above
edgeDF <- read.delim("results/edgeRglm_allcomp.xls", row.names=1, check.names=FALSE) 
str(edgeDF)
summary(edgeDF)
head(edgeDF)
# get the DEGlist from line 626 above
######## load("data/GO/catdb.RData")
######## rm(catdb)
DEG_list <- filterDEGs(degDF=edgeDF, filter=c(Fold=2, FDR=50), plot=FALSE)
str(DEG_list) # Actual DEG_list
DEG_list
up_down <- DEG_list$UporDown; names(up_down) <- paste(names(up_down), "_up_down", sep="")
str(up_down) # list of up_down's for 9 CMP's
up_down
up <- DEG_list$Up; names(up) <- paste(names(up), "_up", sep="")
up
down <- DEG_list$Down; names(down) <- paste(names(down), "_down", sep="")
down
DEGlist <- c(up_down, up, down)
str(DEGlist) # now list of 27
DEGlist
DEGlist <- DEGlist[sapply(DEGlist, length) > 0]
str(DEGlist) # now list of 19 (blanks are gone)
DEGlist
load(file="DEGlist.RData")
xxx <- clusterProfiler::compareCluster(DEGlist, fun="enrichKEGG", organism="ath", qvalueCutoff=0.05, pvalueCutoff=0.2)
str(xxx)
as.data.frame(xxx)


```
```{r try.clusterProfiler.pdf.pg11.enrichGO, eval=doallCPchunks}
# takes time 1:35

## Not run:
data(geneList)
str(geneList)
geneList
de <- names(geneList)[1:100]
yy <- enrichGO(de, 'org.Hs.eg.db', ont="BP", pvalueCutoff=0.01)
head(yy)
## End(Not run)

# my code
load(file="descv.RData")
de = names(descv)[1:100]
de = names(descv)
if (length(de) == 100) {
	Cutoff = 1.0
} else {
	Cutoff = 0.55 # 0.01 # try 1.0 if needed
}
Cutoff
yyy = clusterProfiler::enrichGO(de, OrgDb = 'org.At.tair.db', keytype="TAIR", ont="MF", pAdjustMethod = "BH", qvalueCutoff=Cutoff, pvalueCutoff=Cutoff)
ego = yyy
head(summary(yyy))
yyy2 = DOSE::setReadable(yyy, OrgDb = 'org.At.tair.db', keytype="TAIR")
head(summary(yyy2))
# clusterProfiler Visualization
barplot(ego, showCategory=8)
dotplot(ego)
enrichMap(ego)
cnetplot(ego, categorySize="pvalue", foldChange=geneList)
plotGOgraph(ego)


# and to file
grDevices::pdf("results/cP_ego_barplot.pdf")
barplot(ego, showCategory=8)
dev.off()
grDevices::pdf("results/cP_ego_dotplot.pdf")
dotplot(ego)
dev.off()
grDevices::pdf("results/cP_ego_enrichMap.pdf")
enrichMap(ego)
dev.off()
grDevices::pdf("results/cP_ego_cnetplot.pdf")
cnetplot(ego, categorySize="pvalue", foldChange=geneList)
dev.off()
grDevices::pdf("results/cP_ego_plotGOgraph.pdf")
plotGOgraph(ego)
dev.off()

```
```{r try.clusterProfiler.pdf.pg12.enrichKEGG, eval=T}
# takes time <:03 # eval=T is ok

## Not run:
data(geneList)
de <- names(geneList)[1:100]
de <- names(geneList)
de
geneList
yy <- enrichKEGG(de, qvalueCutoff=1, pvalueCutoff=1)
eKEGG = yy
head(yy)
# plot(yy) # where does this output to? # needs X11
# grDevices::pdf("results/cP_eKEGG_plot.pdf")
# plot(eKEGG) # made a blank page, nothing to plot in eKEGG, error in knit - needs finite xlim
# dev.off()
## End(Not run)

# my code
load(file="descv.RData")
length(names(descv))
de = names(descv)[1:100]
de = names(descv)
de
if (length(de) == 100) {
	Cutoff = 1.0
} else {
	Cutoff = 0.01 # try 1.0 if needed
}
Cutoff
yyy = clusterProfiler::enrichKEGG(de, organism='ath',  pvalueCutoff=Cutoff, qvalueCutoff=Cutoff)
head(summary(yyy))
yyy2 = DOSE::setReadable(yyy, OrgDb = 'org.At.tair.db', keytype="TAIR")
head(summary(yyy2))


```
```{r try.clusterProfiler.pdf.pg16.groupGO, eval=doallCPchunks}
# takes time 2:00 

## Not run:
data(gcSample)
yy <- groupGO(gcSample[[1]], 'org.Hs.eg.db', ont="BP", level=2)
head(summary(yy))
#plot(yy)

# my code
# get edgeDF from line 518 above
edgeDF <- read.delim("results/edgeRglm_allcomp.xls", row.names=1, check.names=FALSE) 
str(edgeDF)
summary(edgeDF)
head(edgeDF)
# get the DEGlist from line 626 above
load("data/GO/catdb.RData")
DEG_list <- filterDEGs(degDF=edgeDF, filter=c(Fold=2, FDR=50), plot=FALSE)
str(DEG_list) # Actual DEG_list
DEG_list
up_down <- DEG_list$UporDown; names(up_down) <- paste(names(up_down), "_up_down", sep="")
str(up_down) # list of up_down's for 9 CMP's
up_down
up <- DEG_list$Up; names(up) <- paste(names(up), "_up", sep="")
up
down <- DEG_list$Down; names(down) <- paste(names(down), "_down", sep="")
down
DEGlist <- c(up_down, up, down)
str(DEGlist) # now list of 27
DEGlist
DEGlist <- DEGlist[sapply(DEGlist, length) > 0]
str(DEGlist) # now list of 19 (blanks are gone)
DEGlist
load(file="DEGlist.RData")
str(DEGlist) # now list of 19 (blanks are gone)

yyyyBP <- clusterProfiler::groupGO(DEGlist[[1]], OrgDb = 'org.At.tair.db', keytype="TAIR", ont="BP", level=2)
ggo = yyyyBP
head(summary(yyyyBP))
yyyyCC <- clusterProfiler::groupGO(DEGlist[[1]], OrgDb = 'org.At.tair.db', keytype="TAIR", ont="CC", level=2)
head(summary(yyyyCC))
yyyyMF <- clusterProfiler::groupGO(DEGlist[[1]], OrgDb = 'org.At.tair.db', keytype="TAIR", ont="MF", level=2)
head(summary(yyyyMF))
# clusterProfiler Visualization
barplot(ggo, drop=TRUE, showCategory=12)
grDevices::pdf("results/cP_ggo_barplot.pdf")
barplot(ggo, drop=TRUE, showCategory=12)
dev.off()
## End(Not run)


```


# Version Information

```{r sessionInfo}
sessionInfo()
```

# Funding

This project was supported by funds from the National Institutes of Health (NIH).

# References

